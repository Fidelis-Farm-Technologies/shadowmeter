--  Copyright 2007-2023 Carnegie Mellon University
--  See license information in LICENSE.txt.

------------------------------------------------------------------------------
--  yafDPIRules.conf
--  Application labeling and Deep Packet Inspection Rules for YAF
-- ---------------------------------------------------------------------------
--  Authors: Emily Ecoff, Chris Inacio, Brian Trammell
------------------------------------------------------------------------------
--
-- This file configures yaf to perform deep packet inspection of the
-- payload captured with a flow record.
--
-- This file is written in Lua.  For specifics of the Lua language, see
-- http://www.lua.org/manual/5.3/manual.html#3
--
-- Comments in Lua start with '--' and continue to the end of the line.
--
-- Further explanation of this file's purpose and syntax is given at the end
-- of the file.  See "PURPOSE AND SYNTAX" below.
--

------------------------------------------------------------------------------
--
-- Distribution Statement
-- ----------------------
--
--  @DISTRIBUTION_STATEMENT_BEGIN@
--  YAF 3.0.0
--
--  Copyright 2023 Carnegie Mellon University.
--
--  NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
--  INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
--  UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
--  AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR
--  PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF
--  THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF
--  ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT
--  INFRINGEMENT.
--
--  Licensed under a GNU GPL 2.0-style license, please see LICENSE.txt or
--  contact permission@sei.cmu.edu for full terms.
--
--  [DISTRIBUTION STATEMENT A] This material has been approved for public
--  release and unlimited distribution.  Please see Copyright notice for
--  non-US Government use and distribution.
--
--  GOVERNMENT PURPOSE RIGHTS â€“ Software and Software Documentation
--  Contract No.: FA8702-15-D-0002
--  Contractor Name: Carnegie Mellon University
--  Contractor Address: 4500 Fifth Avenue, Pittsburgh, PA 15213
--
--  The Government's rights to use, modify, reproduce, release, perform,
--  display, or disclose this software are restricted by paragraph (b)(2) of
--  the Rights in Noncommercial Computer Software and Noncommercial Computer
--  Software Documentation clause contained in the above identified
--  contract. No restrictions apply after the expiration date shown
--  above. Any reproduction of the software or portions thereof marked with
--  this legend must also reproduce the markings.
--
--  This Software includes and/or makes use of Third-Party Software each
--  subject to its own license.
--
--  DM23-2317
--  @DISTRIBUTION_STATEMENT_END@
--

------------------------------------------------------------------------------
--
-- File Compatibility Version
-- --------------------------
--
-- The required "dpirules_version" variable declares that this file conforms
-- to the specified version of the yafDPIRules configuration file format.  To
-- see the version of the format yaf expects, call yaf_get_dpi_version().
--
-- yaf reports an error if it does not support the value specified in this
-- variable.  As of yaf-3.0.0, only version 1 is defined.
dpirules_version = 1

------------------------------------------------------------------------------
--
-- Global DPI Configuration Limits
-- -------------------------------
--
-- These values limit the amount of data collected.
--
-- The "per_field_limit" sets the number of bytes yaf will export for any
-- given field in this file. This does not affect the DNS Deep Packet
-- Inspection or SSL Certificate Capture. For DNS, a domain name can have
-- a maximum of 255 characters, so the limit is not configurable.
--
-- The "per_record_limit" sets the total number of bytes yaf will export
-- from the DPI plugin per record.  Obviously, this number will not be
-- larger than the --max-payload value yaf is given at run time.
--
-- Both the field and record limits have a maximum value of 65535. If they
-- are larger, they will be set back to the defaults of 200 for per-field
-- limit and 1000 for total limit.

-- limit byte count per field length (default 200)
per_field_limit = 200

-- limit total byte count per record (default 1000)
per_record_limit = 1000

------------------------------------------------------------------------------
--
-- Optional Application-Specific Customization
-- -------------------------------------------
--
-- The following variables are passed as arguments to the named plugin.  They
-- appear here for easy customization.
--
-- TLS/SSL DPI settings (tlsplugin)
-- --------------------------------
--
-- Whether to export the entire binary X.509 Certificate and disable normal
-- TLS/SSL Deep Packet Inspection (true/false).  Default is false.
cert_export_enabled = false

-- Whether to export the hash of the X.509 Certificate (true/false).  If true,
-- enables TLS/SSL DPI regardless of the value of 'cert_export_enabled'.
-- Default is false.
cert_hash_enabled = false

-- DNS DPI Settings (dnsplugin)
-- ----------------------------
--
-- Whether to enable export of DNSSEC information in the DNS DPI (true/false).
-- Default is false.
dnssec_enabled = false

------------------------------------------------------------------------------
--
-- Definition of new Information Elements
-- --------------------------------------
--
-- The optional elements variable.  Its syntax is described near the end of
-- this file.

--elements = {
--  {name = "httpStylesheet", id = 1099, is_string = true}
--}

------------------------------------------------------------------------------
--
-- Applabel/DPI Rules
-- ------------------

-- The following are local Lua variables referenced in the applabels table

-- If true, add IEs for HTTP Mobile DPI detection
http_mobile = false

-- If true, add IEs for extra HTTP fields
http_extra = false

-- The required applabels variable.  Its syntax is described near the end of
-- this file.

applabels = {
  -- SSL/Proxied - choose proxy port!
  -- {label = <N>, label_type = "plugin", value = "proxyplugin",
  --  plugin_rules = {
  --    httpConnectRegex = [=[^CONNECT [-a-zA-Z0-9.~;_]+:\d+ HTTP/\d\.\d\b]=],
  --    httpConnectEstRegex = [=[^HTTP/\d\.\d 200 [Cc]onnection [Ee]stablished\b]=],
  --  },
  -- },

  -- HTTP
  {label = 80, label_type = "regex", active = true,
   value = [=[HTTP/\d]=],
   dpi_type = "regex", dpi_name = "http", dpi_template_id = 0xC600,
   dpi_rules = {
     {elem_name = "httpServerString",
      regex = [=[^Server: ?([-a-zA-Z0-9.~!/:;@#$%^&*=+,_() ]+)]=]},
     {elem_name = "httpUserAgent",
      regex = [=[^User-Agent: ?([-a-zA-Z0-9.~!/:;@#$%^&*=+,_() ]+)]=]},
     {elem_name = "httpGet",
      regex = [=[^((GET|HEAD|POST|CONNECT|OPTIONS|DELETE|TRACE|PUT) [[:graph:]]+)]=]},
     {elem_name = "httpConnection",
      regex = [=[^[Cc]onnection: ?([-a-zA-Z0-9;:=,_ ]+)]=]},
     {elem_name = "httpReferer",
      regex = [=[^Referer: ?([[:print:]]+)]=]},
     {elem_name = "httpLocation",
      regex = [=[^Location: ?([[:print:]]+)]=]},
     {elem_name = "httpHost",
      regex = [=[^Host: ?([-a-zA-Z0-9.~!/:;@#$%^&*=+ ]*)]=]},
     {elem_name = "httpContentLength",
      regex = [=[^(?i)Content-Length: ?([0-9]+)]=]},
     {elem_name = "httpAge",
      regex = [=[^Age: ([0-9]+)]=]},
     {elem_name = "httpResponse",
      regex = [=[([1-5][01][0-9] [a-zA-Z ]+)]=]},
     {elem_name = "httpAcceptLanguage",
      regex = [=[^Accept-Language: ?([[:print:]]+)]=]},
     {elem_name = "httpAccept",
      regex = [=[^Accept: ?([[:print:]]+)]=]},
     {elem_name = "httpContentType",
      regex = [=[^(?i)Content-Type: ?([[:print:]]+)]=]},
     {elem_name = "httpVersion",
      regex = [=[(HTTP/\d\.\d)\b]=]},
     {elem_name = "httpCookie",
      regex = [=[^Cookie: ?([[:print:]]+)]=]},
     {elem_name = "httpSetCookie",
      regex = [=[^Set-Cookie: ?([[:print:]]+)]=]},
     {elem_name = "httpAuthorization",
      regex = [=[^Authorization: ?([[:print:]]+)]=]},
     {elem_name = "httpVia",
      regex = [=[^Via: ?([[:print:]]+)]=]},
     {elem_name = "httpXForwardedFor",
      regex = [=[^(?i)x-forwarded-for: ?([-a-zA-Z0-9.,~!/:;@#$%^&*=+ ]*)]=]},
     {elem_name = "httpRefresh",
      regex = [=[^Refresh: ?([[:print:]]+)]=]},
     --{elem_name = "httpStylesheet",
     -- regex = [=[stylesheet]=]},

     -- HTTP Mobile - turned off by default
     {elem_name = "httpIMEI", active = http_mobile,
      regex = [=[^(?i)x-[-a-zA-Z0-9]*imei: ?([0-9]+)]=]},
     {elem_name = "httpIMSI", active = http_mobile,
      regex = [=[^(?i)x-[-a-zA-Z0-9]*imsi: ?([0-9]+)]=]},
     -- the following 3 regexs all describe the same "thing" - hence same name
     {elem_name = "httpMSISDN", active = http_mobile,
      regex = [=[^(?i)x-[-a-zA-Z0-9]*msisdn: ?([0-9]+)]=]},
     {elem_name = "httpMSISDN", active = http_mobile,
      regex = [=[^(?i)x-[-a-zA-Z0-9]*identity: ?([0-9]+)]=]},
     {elem_name = "httpMSISDN", active = http_mobile,
      regex = [=[^x-[wau]+p-calling-line-id: ?([0-9]+)]=]},
     {elem_name = "httpSubscriber", active = http_mobile,
      regex = [=[^(?i)x-opwv-ddm-identity: ([-a-zA-Z0-9.~!/:;@#$%^&*=+,_ ]*)]=]},

     -- HTTP Extra Fields - turned off by default
     {elem_name = "httpExpires", active = http_extra,
      regex = [=[^Expires: ?([a-zA-Z0-9:, ]+)]=]},
     {elem_name = "httpAcceptCharset", active = http_extra,
      regex = [=[^[aA]ccept-[cC]harset: ?([[:print:]]+)]=]},
     {elem_name = "httpAcceptEncoding", active = http_extra,
      regex = [=[^[aA]ccept-[eE]ncoding: ?([[:print:]]+)]=]},
     {elem_name = "httpAllow", active = http_extra,
      regex = [=[^[aA]llow: ?([[:print:]]+)]=]},
     {elem_name = "httpDate", active = http_extra,
      regex = [=[^Date: ?([a-zA-Z0-9:, ]+)]=]},
     {elem_name = "httpExpect", active = http_extra,
      regex = [=[^Expect: ?([[:print:]]+)]=]},
     {elem_name = "httpFrom", active = http_extra,
      regex = [=[^[fF]rom: ?([[:print:]]+)]=]},
     {elem_name = "httpProxyAuthentication", active = http_extra,
      regex = [=[^[pP]roxy-[aA]uthorization: ?([[:print:]]+)]=]},
     {elem_name = "httpUpgrade", active = http_extra,
      regex = [=[^Upgrade: ?([[:print:]]+)]=]},
     {elem_name = "httpWarning", active = http_extra,
      regex = [=[^Warning: ?([[:print:]]+)]=]},
     {elem_name = "httpDNT", active = http_extra,
      regex = [=[^DNT: ?(0|1)]=]},
     {elem_name = "httpXForwardedProto", active = http_extra,
      regex = [=[^(?i)x-forwarded-proto: ?([[:print:]]+)]=]},
     {elem_name = "httpXForwardedHost", active = http_extra,
      regex = [=[^(?i)x-forwarded-host: ?([[:print:]]+)]=]},
     {elem_name = "httpXForwardedServer", active = http_extra,
      regex = [=[^(?i)x-forwarded-server: ?([[:print:]]+)]=]},
     {elem_name = "httpXDeviceId", active = http_extra,
      regex = [=[^(?i)x-[a-z]+-deviceid: ?([[:print:]]+)]=]},
     {elem_name = "httpXProfile", active = http_extra,
      regex = [=[^(?i)x-wap-profile: ?([[:print:]]+)]=]},
     {elem_name = "httpLastModified", active = http_extra,
      regex = [=[^[lL]ast-[mM]odified: ?([a-zA-Z0-9:, ]+)]=]},
     {elem_name = "httpContentEncoding", active = http_extra,
      regex = [=[^[cC]ontent-[eE]ncoding: ?([[:print:]]+)]=]},
     {elem_name = "httpContentLanguage", active = http_extra,
      regex = [=[^[cC]ontent-[lL]anguage: ?([[:print:]]+)]=]},
     {elem_name = "httpContentLocation", active = http_extra,
      regex = [=[^[cC]ontent-[lL]ocation: ?([[:print:]]+)]=]},
     {elem_name = "httpXUaCompatible", active = http_extra,
      regex = [=[^(?i)x-ua-compatible: ?([[:print:]]+)]=]},
   },
  },

  -- SSH
  {label = 22, label_type = "plugin", active = true,
   value =[[sshplugin]],
   dpi_type = "plugin",
   dpi_templates = {
     yaf_ssh = {
       "sshVersion",
       "sshServerVersion",
       "sshKeyExchangeAlgorithm",
       "sshHostKeyAlgorithm",
       "sshServerHostKey",
       "sshCipher",
       "sshMacAlgorithm",
       "sshCompressionMethod",
       "sshHassh",
       "sshServerHassh",
       "sshHasshAlgorithms",
       "sshServerHasshAlgorithms",
      },
     },
   plugin_rules = {
      sshVersionRegex = [=[(?m)^(SSH-\d\.\d+-[ -~]{1,255})\r?\n]=],
   },
  },

  -- SMTP
  {label = 25, label_type = "plugin", active = true,
   value = "smtpplugin", dpi_type = "plugin",
   --
   -- The yaf_smtp_header record contains a limited number of key-value pairs
   -- where each key is a header present in the email.  To prevent a header
   -- from being captured, add the COMPLETE header name or a regex matching
   -- that header to args.  For example, to prevent capture of DKIM-related
   -- headers, use args = {"dkim.+"}.  Header matches are case insensitve.  Do
   -- not use ^ or : as part of the regular expression; they are added by the
   -- plugin.
   --
   args = { },
   dpi_templates = {
     yaf_smtp = {
       "smtpHello",
       "smtpResponseList",
       "smtpMessageList",
       "smtpStartTLS",
     },
     yaf_smtp_message = {
       "smtpSubject",
       "smtpToList",
       "smtpFromList",
       "smtpFilenameList",
       "smtpURLList",
       "smtpHeaderList",
       "smtpMessageSize",
     },
     yaf_smtp_header = {
       "smtpKey",
       "smtpValue",
     },
   },
   plugin_rules = {
     smtpRegexApplabel = [=[(?i)^\s*(?:(?:HE|EH)LO\b|MAIL FROM:|RCPT TO:|(2[25]0[ -].*E?SMTP))]=],
     smtpRegexDataBdat = [=[(?im)^(?:DATA|BDAT +(\d+(?:| +LAST)))\r\n]=],
     smtpRegexBdatLast = [=[(?im)^BDAT +(\d+) +LAST\r\n]=],
     smtpRegexEndData = [=[\r\n\.\r\n]=],
     smtpRegexBlankLine = [=[\r\n\r\n]=],
     smtpRegexHello = [=[(?im)^((?:HELO|EHLO) [!-~]+)\r\n]=],
     smtpRegexSize = [=[(?im)^MAIL FROM:.+ SIZE=(\d+)\s]=],
     smtpRegexStartTLS = [=[(?im)^STARTTLS\r\n]=],
     -- limit responses to the 220 welcome banner and error codes
     smtpRegexResponse = [=[(?m)^((?:220|[45][0-5][0-9])[- ][\t -~]*)\r\n]=],
     smtpRegexTo = [=[(?im)^RCPT TO: ?<?((?:@[-A-Z0-9.](?:,@[-A-Z0-9.])*:)?(?:[!#-+\-./0-9=?@A-Z^_`a-z{|}~]+|"(?:[ !#-\[\]-~]+|\\[ -~])*"))>?(?: |\r\n)]=],
     smtpRegexFrom = [=[(?im)^MAIL FROM: ?<?((?:@[-A-Z0-9.](?:,@[-A-Z0-9.])*:)?(?:[!#-+\-./0-9=?@A-Z^_`a-z{|}~]+|"(?:[ !#-\[\]-~]+|\\[ -~])*"))>?(?: |\r\n)]=],
     smtpRegexHeader = [=[^([!-9;-~]+:(?:[\t -~]|\r\n[\t ])+)\r\n]=],
     smtpRegexSubject = [=[(?im)^Subject:(?:[\t ]|\r\n[\t ])*((?:[\t -~]|\r\n[\t ])+)\r\n]=],
     -- a filename may be in double quotes (which supports \-quoting of a character) or unquoted with a restricted character set
     smtpRegexFilename = [=[(?im)^Content-Disposition:(?:[\t -~]|\r\n[\t ])*;(?:[\t ]|\r\n[\t ])*filename=("(?:[\t !#-\[\]-~]|\\.|\r\n[\t ])*"|[!#-+\-./0-9=?A-Z^_`a-z{|}~]+)]=],
     smtpRegexURL = [=[https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&/=]*)]=],
   },
  },

  -- DNS --- The plugin also identifies NetBIOS.  The plugin takes a single
  -- boolean argument that, if true, enables export of DNSSEC information.
  {label = 53, ports = {137}, label_type = "plugin", active = true,
   value = "dnsplugin", args = {dnssec_enabled}, dpi_type = "plugin",
   dpi_templates = {
     yaf_dns_rr = {
       "dnsDetailRecordList",
       "dnsName",
       "dnsTTL",
       "dnsRRType",
       "dnsQueryResponse",
       "dnsAuthoritative",
       "dnsResponseCode",
       "dnsSection",
       "dnsId",
     },
     yaf_dns_a = {
       "dnsA",
     },
     yaf_dns_aaaa = {
       "dnsAAAA",
     },
     yaf_dns_cname = {
       "dnsCNAME",
     },
     yaf_dns_mx = {
       "dnsMXExchange",
       "dnsMXPreference",
     },
     yaf_dns_ns = {
       "dnsNSDName",
     },
     yaf_dns_ptr = {
       "dnsPTRDName",
     },
     yaf_dns_txt = {
       "dnsTXTData",
     },
     yaf_dns_srv = {
       "dnsSRVTarget",
       "dnsSRVPriority",
       "dnsSRVWeight",
       "dnsSRVPort",
     },
     yaf_dns_soa = {
       "dnsSOAMName",
       "dnsSOARName",
       "dnsSOASerial",
       "dnsSOARefresh",
       "dnsSOARetry",
       "dnsSOAExpire",
       "dnsSOAMinimum",
     },
     yaf_dns_ds = {
       "dnsDSDigest",
       "dnsDSKeyTag",
       "dnsDSAlgorithm",
       "dnsDSDigestType",
     },
     yaf_dns_rrsig = {
       "dnsRRSIGSigner",
       "dnsRRSIGSignature",
       "dnsRRSIGSignatureInception",
       "dnsRRSIGSignatureExpiration",
       "dnsRRSIGOriginalTTL",
       "dnsRRSIGKeyTag",
       "dnsRRSIGTypeCovered",
       "dnsRRSIGAlgorithm",
       "dnsRRSIGLabels",
     },
     yaf_dns_nsec = {
       "dnsNSECNextDomainName",
       "dnsNSECTypeBitMaps",
     },
     yaf_dns_dnskey = {
       "dnsDNSKEYPublicKey",
       "dnsDNSKEYFlags",
       "dnsDNSKEYProtocol",
       "dnsDNSKEYAlgorithm",
     },
     yaf_dns_nsec3 = {
       "dnsNSEC3Salt",
       "dnsNSEC3NextHashedOwnerName",
       "dnsNSEC3TypeBitMaps",
       "dnsNSEC3Iterations",
       "dnsNSEC3Algorithm",
       "dnsNSEC3Flags",
     },
     yaf_dns_nsec3param = {
       "dnsNSEC3PARAMSalt",
       "dnsNSEC3PARAMIterations",
       "dnsNSEC3PARAMAlgorithm",
       "dnsNSEC3PARAMFlags",
     },
   },
  },

  -- FTP
  {label = 21, label_type = "regex", active = true,
   value = [=[(?i)^\s*(ACCT|AUTH\s(SSL|TLS|GSSAPI)|ADAT\s|220[ -].*(FTP|FileZilla)|REST\s+\d|RETR\s+|CWD\s+|STOU|PASV|USER\s)]=],
   dpi_type = "regex", dpi_name = "ftp", dpi_template_id = 0xC700,
   dpi_rules = {
     {elem_name = "ftpReturn",
      regex = [=[^(?i)(REST|RETR|STO[RU] [-a-zA-Z0-9_ ]+)\b]=]},
     {elem_name = "ftpUser",
      regex = [=[^(?i)USER ([-_a-zA-Z0-9]+)\b]=]},
     {elem_name = "ftpPass",
      regex = [=[^(?i)PASS ?([[:print:]]+)]=]},
     {elem_name = "ftpType",
      regex = [=[^(?i)TYPE (A|E|I)\b]=]},
     {elem_name = "ftpRespCode",
      regex = [=[^(?i)([1-5][0-5][0-7] ?[-a-zA-Z0-9.() ]+)\b]=]},
   },
  },

  -- TLS/SSL --- The plugin takes two boolean arguments: The first, if true,
  -- enables export of the full X.509 certifcate and disables the default TLS
  -- DPI processing. The second, if true, exports the hash of the X.509
  -- certificate and enables DPI processing regardless of the first argument.
  {label = 443, label_type = "plugin", active = true,
   value = "tlsplugin", args = {cert_export_enabled, cert_hash_enabled},
   dpi_type = "plugin",
   dpi_templates = {
     yaf_ssl = {
       "sslCipherList",
       "sslServerName",
       "sslCertList",
       "sslServerCipher",
       "sslClientVersion",
       "sslCompressionMethod",
       "sslRecordVersion",
       "sslClientJA3",
       "sslServerJA3S",
       "sslClientJA3Fingerprint",
       "sslServerJA3SFingerprint",
     },
     yaf_ssl_cert = {
       "sslIssuerFieldList",
       "sslSubjectFieldList",
       "sslExtensionFieldList",
       "sslCertSignature",
       "sslCertSignature",
       "sslCertSerialNumber",
       "sslCertValidityNotBefore",
       "sslCertValidityNotAfter",
       "sslPublicKeyAlgorithm",
       "sslPublicKeyLength",
       "sslCertVersion",
       "sslCertificateHash",
     },
     yaf_ssl_subcert = {
       "sslObjectValue",
       "sslObjectType",
     },
   },
  },

  -- QUIC (IETF) - supports draft versions 23-32, version negotiation, and
  -- future RFC version
  {label = 51443, label_type = "regex", active = true,
   value = [=[^[\xC0-\xCF](\xFF\x00{2}[\x17-\x20]|\x0A{4}|\x00{3}\x01)]=]},

  -- SLP
  {label = 427, label_type = "plugin", active = true,
   value = "slpplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_slp = {
       "slpStringList",
       "slpVersion",
       "slpMessageType",
     },
   },
  },

  -- SMB
  {label = 139, label_type = "regex", active = true,
   value = [=[^.{0,5}\x00...(\xFF|\xFE)SMB]=]},

  -- IMAP
  {label = 143, label_type = "regex", active = true,
   value = [=[(?i)^\s*(.{1,7}\s(CAPABILITY|AUTHENTICATE|STARTTLS|LOGIN|FETCH)|\*\s.*IMAP)]=],
   dpi_type = "regex", dpi_name = "imap", dpi_template_id = 0xC800,
   dpi_rules = {
     {elem_name = "imapCapability",
      regex = [=[CAPABILITY ([-a-zA-Z0-9+= ]+)\b]=]},
     {elem_name = "imapLogin",
      regex = [=[LOGIN ([a-zA-Z0-9" ]+)\b]=]},
     {elem_name = "imapStartTLS",
      regex = [=[(STARTTLS)\b]=]},
     {elem_name = "imapAuthenticate",
      regex = [=[AUTHENTICATE ([a-zA-Z0-9]+)\b]=]},
     {elem_name = "imapCommand",
      regex = [=[((SELECT|COPY|EXAMINE|CREATE|DELETE|RENAME|(UN)?SUBSCRIBE|LIST|LSUB|STATUS|APPEND) [-a-zA-Z0-9/.:()" *\\]+)]=]},
     {elem_name = "imapExists",
      regex = [=[^\x2A? ?([0-9]* EXISTS)\b]=]},
     {elem_name = "imapRecent",
      regex = [=[^\x2A? ?([0-9]* RECENT)\b]=]},
   },
  },

  -- IRC -- Include the de facto port
  {label = 194, ports = {6667}, label_type = "plugin", active = true,
   value = "ircplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_irc = {
       "ircTextMessageList",
     },
   },
   plugin_rules = {
     ircRegex = [=[^((?:(:[^: \n\r]+)(?:\ ))?(PASS|OPER|QUIT|SQUIT|NICK|MODE|USER|SERVICE|JOIN|NAMES|INVITE|PART|TOPIC|LIST|KICK|PRIVMSG|NOTICE|MOTD|STATS|CONNECT|INFO|LUSERS|LINKS|TRACE|VERSION|TIME|ADMIN|SERVLIST|SQUERY|WHO|WHOWAS|WHOIS|KILL|PING|PONG|ERROR|AWAY|DIE|SUMMON|REHASH|RESTART|USERS|USERHOST)[ a-zA-Z0-9$#.:*"]*)(?:[\r\n])]=],
     ircMsgRegex = [=[^(?:(:[^: \n\r]+)(?:\ ))?(PRIVMSG|NOTICE) \ ([^: \n\r]+|:.*) (?:\ )([^: \n\r]+\ |:.*)]=],
     ircDPIRegex = [=[((\d{3}|PASS|OPER|QUIT|SQUIT|NICK|MODE|USER|SERVICE|JOIN|NAMES|INVITE|PART|TOPIC|LIST|KICK|PRIVMSG|MOTD|STATS|CONNECT|INFO|LUSERS|LINKS|TRACE|VERSION|TIME|ADMIN|SERVLIST|SQUERY|WHO|WHOWAS|WHOIS|KILL|PING|PONG|ERROR|AWAY|DIE|SUMMON|REHASH|RESTART|USERS|USERHOST|PROTOCTL) [-a-zA-Z0-9$#.:*" ]*)(?:[\r\n])]=],
   },
  },

  -- RTSP
  {label = 554, label_type = "regex", active = true,
   value = [=[RTSP/\d\.\d\b]=],
   dpi_type = "regex", dpi_name = "rtsp", dpi_template_id = 0xC900,
   dpi_rules = {
     {elem_name = "rtspURL",
      regex = [=[rtsp://([-a-zA-Z0-9.:]*/\S*)]=]},
     {elem_name = "rtspVersion",
      regex = [=[(RTSP/\d.\d)]=]},
     {elem_name = "rtspReturnCode",
      regex = [=[((?=RTSP/\d.\d) [1-5][015][0-9] [a-zA-Z ]+)\b]=]},
     {elem_name = "rtspContentLength",
      regex = [=[Content-Length: ([0-9]+)\b]=]},
     {elem_name = "rtspCommand",
      regex = [=[([A-Z]+ (?:rtsp://[-a-zA-Z0-9.:]*/*\S*))]=]},
     {elem_name = "rtspContentType",
      regex = [=[(?i)Content-Type: ([-a-zA-Z0-9/]+)\b]=]},
     {elem_name = "rtspTransport",
      regex = [=[^Transport: ([-a-zA-Z0-9/;=_]+)\b]=]},
     {elem_name = "rtspCSeq",
      regex = [=[CSeq: ([0-9]+)\b]=]},
     {elem_name = "rtspLocation",
      regex = [=[Location: rtsp://([-a-zA-Z0-9.:/]*/\S*)]=]},
     {elem_name = "rtspPacketsReceived",
      regex = [=[(?i)packets_received: ?([0-9]+)\b]=]},
     {elem_name = "rtspUserAgent",
      regex = [=[^User-Agent: ([-a-zA-Z0-9_ ]+)\b]=]},
     {elem_name = "rtspJitter",
      regex = [=[^(?i)Jitter: ?([0-9.]+)\r\n]=]},
   },
  },

  -- SIP
  {label = 5060, label_type = "regex", active = true,
   value = [=[SIP/\d\.\d\b]=],
   dpi_type = "regex", dpi_name = "sip", dpi_template_id = 0xCA00,
   dpi_rules = {
     {elem_name = "sipInvite",
      regex = [=[^INVITE sip:([-a-zA-Z0-9.@=;]* SIP/\d\.\d)\b]=]},
     {elem_name = "sipCommand",
      regex = [=[^((OPTIONS|ACK|BYE|CANCEL|REGISTER|SUBSCRIBE) sip:[-a-zA-Z0-9.@=;]* SIP/\d\.\d)\b]=]},
     {elem_name = "sipVia",
      regex = [=[^(Via: SIP/\d\.\d/[TU][DC]P [-a-zA-Z0-9.@:;=]*)]=]},
     {elem_name = "sipMaxForwards",
      regex = [=[^Max-Forwards: ([0-9]+)]=]},
     {elem_name = "sipAddress",
      regex = [=[^(?i)((To|From|Contact): ?([[:print:]]+))]=]},
     {elem_name = "sipContentLength",
      regex = [=[^Content-?Length: ([0-9]+)]=]},
     {elem_name = "sipUserAgent",
      regex = [=[^(?i)User-Agent: ?([[:print:]]+)]=]},
   },
  },

  -- RSYNC
  {label = 873, label_type = "regex", active = true,
   value = [=[^@RSYNCD:]=]},

  -- RDP
  {label = 3389, label_type = "regex", active = true,
   value = [=[^((\x01|\x02|\x03).{4}\xE0\x00{5}|\xFF{4}.{2}.{1}\x01)]=]},

  -- IKEv2 --- See license below
  {label = 500, label_type = "regex", active = true,
   value = [=[^.{16}[\x21-\x36]\x20[\x22-\x29].{9}[\x22-\x29]]=]},

  -- PPTP
  {label = 1723, label_type = "plugin", active = true,
   value = "pptpplugin"},

  -- NNTP
  {label = 119, label_type = "plugin", active = true,
   value = "nntpplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_nntp = {
       "nntpResponseList",
       "nntpCommandList",
     },
   },
   plugin_rules = {
     nntpCommandRegex = [=[^((ARTICLE|GROUP|HELP|IHAVE|LAST|LIST|NEWGROUPS|NEWNEWS|NEXT|POST|QUIT|SLAVE|STAT|MODE) ?[ a-zA-Z0-9.]*)[ \r\n]]=],
     nntpResponseRegex = [=[(([1-5]([0-4]|[8-9])[0-9] )+.* (text follows)?[\r\n]?(.* \r\n)?)\b]=],
   },
  },

  -- TFTP
  {label = 69, label_type = "plugin", active = true,
   value = "tftpplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_tftp = {
       "tftpFilename",
       "tftpMode",
     },
   },
   plugin_rules = {
     tftpRegex = [=[\x00[\x01|\x02]([-a-zA-Z1-9. ]+)\x00(?i)(netascii|octet|mail)\x00]=],
   },
  },

  -- Teredo
  {label = 3544, label_type = "plugin", active = true,
   value = "teredoplugin"},

  -- MYSQL
  {label = 3306, label_type = "plugin", active = true,
   value = "mysqlplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_mysql = {
       "mysqlCommandTextCodeList",
       "mysqlUsername",
     },
     yaf_mysql_txt = {
       "mysqlCommandText",
       "mysqlCommandCode",
     },
   },
  },

  -- POP3
  {label = 110, label_type = "plugin", active = true,
   value = "pop3plugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_pop3 = {
       "pop3TextMessageList",
     },
   },
   plugin_rules = {
     -- used to determine if this connection looks like POP3;
     -- capture the response to distinguish the server from the client
     pop3RegexResponse = [=[(?m)^((?:\+OK|-ERR)[ -~]*)]=],
     -- capture everything the client says
     pop3RegexRequest = [=[(?im)^[ \t]*([!-~][ !-~]+)]=],
     -- capture the first line of each response
     pop3RegexApplabel = [=[(?i)^\s*(?:(?:CAPA\b|AUTH\s(?:KERBEROS_V|GSSAPI|SKEY)|UIDL\b|APOP\s|USER\s)|(\+OK\b|-ERR\b))]=],
   },
  },

  -- SNMP
  {label = 161, label_type = "plugin", active = true,
   value = "snmpplugin"},

  -- MQTT - supports v3.1 - 5.x
  {label = 1883, label_type = "regex", active = true,
   value = [=[^\x10...\x4D\x51(\x49\x73\x64\x70\x03|\x54\x54[\x04-\x05])]=]},

  -- AIM -- Given declining prevalence, consider setting active to false
  {label = 5190, label_type = "plugin", active = true,
   value = "aolplugin"},

  -- Gnutella p2p
  {label = 6346, label_type = "regex", active = true,
   value = [=[(?i)^(GNUTELLA CONNECT/|gnd[\x01\x02]?.?.?\x01)]=]},

  -- Yahoo Messenger -- Given declining prevalence, consider setting active to
  -- false
  {label = 5050, label_type = "regex", active = true,
   value = [=[^YMSG]=]},

  -- SOCKS
  {label = 1080, label_type = "plugin", active = true,
   value = "socksplugin"},

  -- BGP
  {label = 179, label_type = "plugin", active = true,
   value = "bgpplugin"},

  -- DHCP
  {label = 67, label_type = "plugin", active = true,
   value = "dhcpplugin"},

  -- VNC RFB
  {label = 5900, label_type = "regex", active = true,
   value = [=[^RFB]=]},

  -- RTP/RTCP
  {label = 5004, label_type = "plugin", active = true,
   value = "rtpplugin", dpi_type = "plugin",
   dpi_templates = {
     yaf_rtp = {
       "rtpPayloadType",
       "reverseRtpPayloadType",
     },
   },
  },

  -- Jabber XMPP
  {label = 5222, label_type = "regex", active = true,
   value = [=[jabber:client]=]},

  -- MSNP
  {label = 1863, label_type = "regex", active = true,
   value = [=[^VER \d MSNP\d\d]=]},

  -- MSOffice Update --- Given declining prevalence on unencrypted channels,
  -- consider setting active to false
  {label = 2223, label_type = "regex", active = true,
   value = [=[^MSOPID]=]},

  -- MGCP RFC 3435
  {label = 2427, label_type = "regex", active = true,
   value = [=[MGCP 1.0]=]},

  -- MEGACO, h.248
  {label = 2944, label_type = "regex", active = true,
   value = [=[^MEGACO/1]=]},

  -- VMware Server Console
  {label = 902, label_type = "regex", active = true,
   value = [=[(?i)^220 VMware Authentication Daemon]=]},

  -- BitTorrent
  {label = 6881, label_type = "regex", active = true,
   value = [=[^\x13BitTorrent protocol]=]},

  -- LDAP
  {label = 389, label_type = "plugin", active = true,
   value = "ldapplugin"},

  -- DNP 3.0
  {label = 20000, label_type = "plugin", active = true,
   value = "dnp3plugin",
   --dpi_type = "regex-plugin",
   --dpi_rules = {
   --  {elem_name = "dnp3ObjectData", regex = [=[(\x02[\x00-\xff]+)]=]},
   --}
   dpi_templates = {
     yaf_dnp3 = {
       "dnp3RecordList",
     },
     yaf_dnp3_rec = {
       "dnp3ObjectData",
       "dnp3SourceAddress",
       "dnp3DestinationAddress",
       "dnp3Function",
     },
   },
  },

  -- Modbus
  {label = 502, label_type = "plugin", active = true,
   value = "modbusplugin",
   --dpi_type = "regex-plugin",
   --dpi_rules = {
   --  {elem_name = "modbusData", regex = [=[^\x11..\xFF([a-zA-Z0-9 ]+)]=]},
   --}
   dpi_templates = {
     yaf_modbus = {
       "modbusDataList",
     },
   },
  },

  -- EthIP
  {label = 44818, label_type = "plugin", active = true,
   value = "ethipplugin",
   --dpi_type = "regex-plugin",
   --dpi_rules = {
   --  {elem_name = "enipData", regex = [=[\x63\x00.{6}\x00{16}\x01\x00\x0c\x00..\x01\x00[\x00-\xff]{31}([-a-zA-Z0-9/ ]+)]=]},
   --  -- captures the Name of service in List Services Response packets
   --  {elem_name = "enipData", regex = [=[\x04\x00.{6}\x00{4}[\x00-\xFF]{8}\x00{4}\x01\x00\x00\x01..\x01\x00..([-a-zA-Z0-9/ ]+)]=]},
   --}
   dpi_templates = {
     yaf_enip = {
       "enipDataList",
     },
   },
  },

  -- NetBIOS Datagram Service/SMB
  {label = 138, label_type = "plugin", active = true, value = "netdgmplugin"},

  -- Gh0st
  {label = 9997, label_type = "plugin", active = true, value = "gh0stplugin"},

  -- PI http://badishi.com/initial-analysis-of-poison-ivy/
  {label = 65534, label_type = "plugin", active = true, value = "piplugin"},

  -- LDP
  {label = 646, label_type = "plugin", active = true, value = "ldpplugin"},

  -- Palevo http://walisecurity.wordpress.com/
  {label = 65533, label_type = "plugin", active = true, value = "palplugin"},

  -- NTP
  {label = 123, label_type = "plugin", active = true, value = "ntpplugin"},

  -- Sample Signature
  -- {label = 1000, label_type = "signature", active = true,
  --  value = [[<Find Me>]]},

}


------------------------------------------------------------------------------
--
-- Copyright Notice for Included Regular Expressions
-- -------------------------------------------------
--
-- The regular expression above to capture IKEv2 traffic (port=500) was copied
-- from https://github.com/ukncsc/zeek-plugin-ikev2/blob/master/scripts/dpd.sig
-- and has the following license:
--
--
-- Crown Copyright 2020, All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are met:
--
-- (1) Redistributions of source code must retain the above copyright
--     notice, this list of conditions and the following disclaimer.
--
-- (2) Redistributions in binary form must reproduce the above copyright
--     notice, this list of conditions and the following disclaimer in the
--     documentation and/or other materials provided with the distribution.
--
-- (3) Neither the name of the University of California, Lawrence Berkeley
--     National Laboratory, U.S. Dept. of Energy, International Computer
--     Science Institute, nor the names of contributors may be used to endorse
--     or promote products derived from this software without specific prior
--     written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-- ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
-- LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-- CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-- CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-- POSSIBILITY OF SUCH DAMAGE.
--
-- Note that some files in the distribution may carry their own copyright
-- notices.
--

------------------------------------------------------------------------------
--
-- PURPOSE AND SYNTAX
--
-- PURPOSE OF THIS FILE
-- ====================
--
-- This file configures yaf to perform deep packet inspection of the
-- payload captured with a flow record.  yaf supports two levels of DPI:
--
-- The first level assigns an application label (applabel) to the record.
-- An applabel is the well-known port on which a service normally runs.
-- For example, flows whose packet payload resembles web requests (HTTP)
-- are assigned port 80 and payload that resembles email transfer (SMTP)
-- are assigned 25.
--
-- The second level extracts data from the payload and stores the data in
-- information elements on the flow record.  For example, it can store
-- HTTP headers (httpGet, httpReferer) and SMTP headers (smtpFrom, smtpTo)
-- in the record.
--
-- Although both are a form of deep packet inspection, yaf uses "applabel"
-- when referencing the first and "dpi" when referencing the second.
--
--
-- FORMAT OF THIS FILE
-- ===================
--
-- This file is written in Lua.  For specifics of the Lua language, see
-- http://www.lua.org/manual/5.3/manual.html#3
--
-- Comments in Lua start with '--' and continue to the end of the line.
--
-- This file must define a variable named 'applabels' which is an array of
-- applabel tables. Each applabel table defines a rule that tells yaf how
-- to assign an applabel, what information elements to create when doing
-- dpi, and how to assign values to those elements.
--
--
-- Simple Applabel
-- ---------------
--
-- The simplest applabel rule has the form
--
--     {label = <APP>, label_type = "<label_type>", value = [[<expression>]]}
--
-- where
--
--   <APP> is the application label to apply, and it is an unsigned 16-bit
--   decimal integer in the range 1 to 65535 inclusive.
--
--   <label_type> is the type of rule, a string.  Three label_types of
--   applabel rules are supported: regex, plugin, and signature.  A type of
--   "none" ignores the entry.  These are described in more detail in the
--   "Assigning..."  sections below.
--
--   <expression> specifies how to recognize the given application protocol
--   and is dependent on the label_type.  It is a string.
--
--   Note: The square backets that surround the expression are "long brackets"
--   and surround a "long literal", which is useful for writing regular
--   expressions.  Zero or more equal signs ('=') may appear between each set
--   of brackets (the same number on each side), [====[as an example]====].
--   At least one equal sign is recommended when specifying a regex.
--
-- The simplest form only sets the silkAppLabel field in the flow record; no
-- dpi is preformed.  How to enable DPI is explained in the Complete Applabel
-- section below.
--
-- Here is an example giving a complete definition of applabels.
--
--    applabels = {{label = 80, label_type = "regex",
--                  value = [=[HTTP/\d\.\d\b]=]}}
--
-- Any TCP or UDP flow record whose payload starts with "HTTP/" followed by a
-- digit, a full stop (period), and a digit is assigned the applable 80, and
-- all other flows are assigned applabel 0.
--
--
-- Complete Applabel
-- -----------------
--
-- A complete applabel rule table has the form
--
--     {label = <APP>, label_type = "<label_type>", value = [=[<expression>]=],
--      ports = {PORT_LIST}, protocol = <PROTO>, active = <true|false>,
--      dpi_type = "<dpi_type>", <dpi-regex-entries>}
--
-- where
--
--   <APP>, <label_type>, and <expression> were defined above.
--
--   <PORT_LIST> is optional; if present, is a list of port numbers, from 1 to
--   65535. <PORT_LIST> allows associating multiple ports to an applabel with
--   "regex" or "plugin" label_type.  If "ports" is not present, only the
--   "label" (<APP>) is used to check for matches against a flow's source or
--   destination ports.  Values in the <PORT_LIST> must not match any other
--   <APP> or <PORT_LIST> value.
--
--   <PROTO> limits a "regex" label_type to being tested only when the flow
--   record's protocolIdentifier matches <PROTO> or when <PROTO> is 0.  If
--   "protocol" is not present, the test is performed.  <PROTO> is a value
--   between 0 and 255 inclusive, but only 0, 6, and 17 are relevant since yaf
--   only runs applabel checks for TCP and UDP records.  protocol is ignored
--   for "plugin" label_type rules; that check should be performed by the
--   plugin itself.
--
--   <active> is a boolean indicating whether the rule is active, and defaults
--   to true if not present.
--
--   <dpi_type> is how to perform dpi.  The value is a string, and the
--   recognized values are none, regex, plugin, and regex-plugin.  If dpi_type
--   is not present or has the value "none", no dpi is performed.  More
--   details are in the "Assigning..." sections below.
--
--   <dpi-regex-entries> are additional entries dependent on the dpi_type.
--
--
-- Applabel Rule Order
-- -------------------
--
-- The order of the ports in applabels array matters.
--
-- All rules of type signature are checked first in the order they appear in
-- the array.
--
-- If none match, yaf then checks for an applabel rule whose "label" or
-- "ports" values match the source or destination port of the flow record and
-- where the protocol matches, if specified.
--
-- If no applabel rule exists or the rule fails, yaf checks each regex and
-- plugin rule in the array in the order they appear.
--
-- Once a match is found, the labeler stops processing.  It does not attempt
-- to find a better match.
--
--
-- Assigning an Applabel/DPI Using Regular Expressions
-- ---------------------------------------------------
--
-- A "regex" label_type rule has the following form:
--
--     {label = <APP>, label_type = "regex", active = true, protocol = <PROTO>,
--      value = [=[<pcre_regex>]=], dpi_type = "<dpi_type>",
--      dpi_template_id = <tid>, dpi_name = "<name>",
--      dpi_rules = {
--        {elem_name = "<element>", active = true, regex = [=[pcre_regex]=]}
--        ...
--      }}
--
-- The <pcre_regex> is a PCRE (http://www.pcre.org/) regular expression
-- (see PCRE documentation for details, particularly "pcrepattern" and
-- "pcresyntax"). yaf checks the available payload of both directions of
-- the flow with the pcre_regex, and if the expression matches either
-- direction of the payload, the label <APP> is applied to the flow.
--
-- If dpi_type is present (and not "none"), it must "regex", and these
-- additional key-value pairs are required:
--
-- * dpi_template_id is the template ID to assign to the template holding
-- this information.  The ID must be a value between 256 and 65535 and it
-- must not match any other template ID used by yaf.  If this element is
-- not present or 0, an arbitrary ID is assigned.  This template will hold
-- one or more information elements of type basicList.
--
-- * dpi_name is a name to assign to the template; this name is exported
-- as part of the template metadata.  If not present, a name is generated.
--
-- * dpi_rules is an array of tables, where each table describes one
-- information element to appear in the template and a regular expression
-- to extract the data for that element from the payload.  The tables in
-- dpi_rules must have the following entries:
--
-- ** elem_name is the name of the information element to use each value
-- found by the regex.
--
-- ** regex holds a PCRE regular expression that is used to examine the
-- payload.  Each time it matches, a new elem_name item is created.  All
-- the elements are stored in a basicList that is itself added to the
-- template specified by dpi_template_id.
--
-- ** active is an optional boolean value.  If present and false the entry is
-- ignored.
--
-- When creating the template that holds the basicLists, yaf first checks
-- for an information element of whose name is elem_name+"List" and whose
-- type is basicList.  If found, that element is used, otherwise the
-- generic basicList element is used.
--
--
-- Assigning an Applabel/DPI Using A Plugin
-- ----------------------------------------
--
-- Plugin rules are used to label application payload using a C dynamically
-- loaded library, and have the following form:
--
--    {label = <APP>, label_type = "plugin", active = true,
--     value = "<library>", args = {"arg1", "arg2", ...},
--     dpi_type = "<dpi_type>",
--     dpi_templates = {
--       <TEMPLATE_NAME1> = { "ieName1", "ieName2", ... },
--       <TEMPLATE_NAME2> = { "ieName1", "ieName2", ... },
--       ...
--     },
--     plugin_rules = {
--       <VARIABLE_NAME1> = [=[<pcre_regex>]=],
--       <VARIABLE_NAME2> = [=[<pcre_regex>]=],
--       ..
--     },
--    }
--
-- where <library> is the name of a dynamically loadable library that
-- exists somewhere within the LD_LIBRARY_PATH, the LTDL_LIBRARY_PATH, or
-- a system library path, without the library name extension (usually
-- .so). If the plugin returns 1, the flow will be labeled with <APP>.
-- Otherwise, the flow will be labeled with the value the plugin returns
-- (useful for a plugin that can identify more than one protocol).  See the
-- source code to the plugins that ship with YAF for details.
--
-- The "args" key is optional.  If present, its value is an array of
-- strings that are to be passed as arguments to the plugin.
--
-- If dpi_type is present (and not "none"), it may be either "plugin" or
-- "regex-plugin".
--
-- If the "dpi_type" key has the value "plugin", the same <library> is used to
-- perform DPI and at least one and perhaps two additional key-value pairs are
-- required.  Those keys are:
--
-- * The dpi_templates key is required.  Its value is a table where each entry
-- respresents one template created by this plugin.  Each key matches the name
-- of a template defined by the plugin, and the value an array of strings
-- containing the information elements exported as part of that template.  The
-- keys of dpi_templates may not be changed since they are defined in the C
-- code of the plugin.  The user may comment out (or remove) entries to
-- prevent those elements from being exported by the plugin.  The order of the
-- elements does not matter and adding additional elements does not add those
-- elements to the exported templates.
--
-- * The plugin_rules key is required by some DPI plugins.  When present, its
-- value is a table, where the keys of the table represent variables defined
-- in the plugin and must not be changed.  The value for each key is a string
-- containing a PCRE regular expression used by the plugin.  The expressions
-- are made available so they can be tweaked by the user, but note that
-- modifying the expressions may also break the plugin.  Removing an entry
-- from this table will cause the plugin to fail to load.
--
-- If the "dpi_type" key has the value "regex-plugin", then the remainder of
-- this rule must have the same form as that described in the previous
-- section.  Namely, entries for dpi_template_id, dpi_name, and dpi_rules are
-- required.
--
--
-- Assigning an Applabel/DPI Using a Signature
-- -------------------------------------------
--
-- For regular expressions that are not tied to a particular port and when
-- no DPI is needed, use the signature rule.  These are processed before
-- the regex and plugin type rules.  A signature type rule has this form:
--
--   {label = <N>, label_type = "signature", active = true,
--    value = [=[<pcre_regex>]=]}
--
-- The pcre_regex is compared against the available payload of the flow;
-- if the expression matches, the label <N> is applied to the flow.
--
--
-- Creating new elements
-- ---------------------
--
-- The variable "elements" may be used to define new information elements
-- within the CERT private enterprise domain.  If defined, it must be an
-- array of tables, where each table represents an element:
--
--    elements = {
--      {name = "<name>", id = <num>, is_string = <true|false>}
--    }
--
-- Each table in elements must contain the keys name and id, where <name>
-- is the name of the element and <num> is its ID.  <name> must be an
-- unused name and <num> must be an unused ID between 1 and 16383
-- inclusive.  The key is_string accepts a boolean; if present and true,
-- the type of the new element is set to string, otherwise the new
-- element's type is octetArray.
--

------------------------------------------------------------------------------

-- Local Variables:
-- mode:lua
-- indent-tabs-mode:nil
-- fill-column:78
-- End:
